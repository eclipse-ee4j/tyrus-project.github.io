<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;8.&nbsp;Tyrus proprietary configuration</title><link rel="stylesheet" type="text/css" href="/documentation.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Tyrus 1.8.1 User Guide"><link rel="up" href="index.html" title="Tyrus 1.8.1 User Guide"><link rel="prev" href="injection.html" title="Chapter&nbsp;7.&nbsp;Injection Support"></head><body class="contents"><div class="contents" bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;8.&nbsp;Tyrus proprietary configuration</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="injection.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;</td></tr></table><hr></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="tyrus-proprietary-config"></a>Chapter&nbsp;8.&nbsp;Tyrus proprietary configuration</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1129">8.1. Client-side SSL configuration</a></span></dt><dd><dl><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1150">8.1.1. Host verification</a></span></dt></dl></dd><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1172">8.2. Asynchronous connectToServer methods</a></span></dt><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1185">8.3. Optimized broadcast</a></span></dt><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1198">8.4. Incoming buffer size</a></span></dt><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1216">8.5. Shared client container</a></span></dt><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1238">8.6. WebSocket Extensions</a></span></dt><dd><dl><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1263">8.6.1. ExtendedExtension sample</a></span></dt><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1284">8.6.2. Per Message Deflate Extension</a></span></dt></dl></dd><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1291">8.7. Client reconnect</a></span></dt><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1300">8.8. Client behind proxy</a></span></dt><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1308">8.9. JDK 7 client</a></span></dt><dd><dl><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1330">8.9.1. SSL configuration</a></span></dt></dl></dd><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1350">8.10. JMX Monitoring</a></span></dt><dd><dl><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1424">8.10.1. Configuration</a></span></dt></dl></dd><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1441">8.11. Maximal number of open sessions on server-side</a></span></dt><dd><dl><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1460">8.11.1. Maximal number of open sessions per application</a></span></dt><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1482">8.11.2. Maximal number of open sessions per remote address</a></span></dt><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1510">8.11.3. Maximal number of open sessions per endpoint</a></span></dt></dl></dd><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1525">8.12. Client HTTP Authentication</a></span></dt><dd><dl><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1550">8.12.1. Credentials</a></span></dt><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1558">8.12.2. Auth Configuration</a></span></dt><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1576">8.12.3. User defined authenticator</a></span></dt><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1603">8.12.4. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1641">8.13. Client HTTP Redirect</a></span></dt><dd><dl><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1658">8.13.1. Supported HTTP response codes</a></span></dt><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1683">8.13.2. Configuration</a></span></dt><dt><span class="section"><a href="tyrus-proprietary-config.html#d0e1715">8.13.3. Exception handling</a></span></dt></dl></dd></dl></div><p>Following settings do have influence on Tyrus behaviour and are <span class="emphasis"><em>NOT</em></span> part of WebSocket
    specification. If you are using following configurable options, your application might not be easily transferable to
    other WebSocket API implementation.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1129"></a>8.1.&nbsp;Client-side SSL configuration</h2></div></div></div><p>When accessing "wss" URLs, Tyrus client will pick up whatever keystore and truststore is actually set for current JVM instance, but
            that might not be always convenient. WebSocket API does not have this feature (yet, see <a class="link" href="https://java.net/jira/browse/WEBSOCKET_SPEC-210" target="_top">WEBSOCKET_SPEC-210</a>),
            so Tyrus exposed two SSL configuration classes <a class="link" href="https://grizzly.java.net/docs/2.3/apidocs/org/glassfish/grizzly/ssl/SSLEngineConfigurator.html" target="_top">SSLEngineConfigurator</a>
            and <a class="link" href="https://tyrus.java.net/apidocs/1.8.1/org/glassfish/tyrus/client/SslEngineConfigurator.html" target="_top">SslEngineConfigurator</a>
            , which can be used for specifying all SSL parameters to be used with current client instance. The former configuration class
            belongs to Grizzly configuration API and therefore works only with Grizzly client. The latter configuration class
            works with both Grizzly and JDK client and offers some extensions over the Grizzly SSLEngineConfigurator
            allowing more control of host verification during the SSL handshake. For more details
            please refer to the following subsection dealing with host verification.

            Additionally, WebSocket API does not have anything like a client, only WebSocketContainer and it does not have any properties, so you need to use Tyrus specific class -
            <a class="link" href="https://tyrus.java.net/apidocs/1.8.1/org/glassfish/tyrus/client/ClientManager.html" target="_top">ClientManager</a>.</p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final ClientManager client = ClientManager.createClient();

System.getProperties().put("javax.net.debug", "all");
System.getProperties().put(SSLContextConfigurator.KEY_STORE_FILE, "...");
System.getProperties().put(SSLContextConfigurator.TRUST_STORE_FILE, "...");
System.getProperties().put(SSLContextConfigurator.KEY_STORE_PASSWORD, "...");
System.getProperties().put(SSLContextConfigurator.TRUST_STORE_PASSWORD, "...");
final SSLContextConfigurator defaultConfig = new SSLContextConfigurator();

defaultConfig.retrieve(System.getProperties());
    // or setup SSLContextConfigurator using its API.

SSLEngineConfigurator sslEngineConfigurator =
    new SSLEngineConfigurator(defaultConfig, true, false, false);
client.getProperties().put(ClientProperties.SSL_ENGINE_CONFIGURATOR,
    sslEngineConfigurator);
client.connectToServer(... , ClientEndpointConfig.Builder.create().build(),
    new URI("wss://localhost:8181/sample-echo/echo"));
}</pre><p>
            If there seems to be a problem with Tyrus SSL connection, it is strongly recommended to use -Djavax.net.debug=all
            system property as it provides invaluable information for troubleshooting.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1150"></a>8.1.1.&nbsp;Host verification</h3></div></div></div><p>
                One of the key steps when establishing SSL connections is verifying that the host on the certificate
                sent by the server matches the host Tyrus client tries to connect to and thus preventing a possibility of
                a man-in-the-middle attack. Host verification is turned on by default in Tyrus, which means that Tyrus
                will automatically check that the host provided in the URI in
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">client.connectToServer(... , new URI("wss://target-server:8181/application/endpoint"));
                </pre><p> matches exactly the host the certificate has been issued for. Exact match is
                the key word in the previous sentence as host can be either hostname or IP address and those two cannot be used
                interchangeably. For instance when a certificate has been issued for "localhost", establishing an SSL connection
                to "wss://127.0.0.1:8181/application/endpoint" will fail as the host does not match the one in the certificate.
            </p><p>
                The default host verification can be too restrictive for some cases and therefore Tyrus provides users
                with means to to either disable the host verification (highly unrecommended in production) or to implement
                their own host verifier. Providing custom host verifier will disable the default one. It is also important
                to note that Grizzly specific
                <a class="link" href="https://grizzly.java.net/docs/2.3/apidocs/org/glassfish/grizzly/ssl/SSLEngineConfigurator.html" target="_top">SSLEngineConfigurator</a>
                does not provide these options and for modifying the default host name verification policy
                <a class="link" href="https://tyrus.java.net/apidocs/1.8.1/org/glassfish/tyrus/client/SslEngineConfigurator.html" target="_top">SslEngineConfigurator</a>
                must be used instead. The following sample shows how to disable host name verification:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">SslEngineConfigurator sslEngineConfigurator = new SslEngineConfigurator(new SslContextConfigurator());
sslEngineConfigurator.setHostVerificationEnabled(false)
client.getProperties().put(ClientProperties.SSL_ENGINE_CONFIGURATOR, sslEngineConfigurator);
                </pre><p>
                The following sample shows how to register a custom host verifier:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">SslEngineConfigurator sslEngineConfigurator = new SslEngineConfigurator(new SslContextConfigurator());
sslEngineConfigurator.setHostnameVerifier(new HostnameVerifier() {
    @Override
    public boolean verify(String host, SSLSession sslSession) {
        Certificate certificate = sslSession.getPeerCertificates()[0];
        // validate the host in the certificate
    }
});
client.getProperties().put(ClientProperties.SSL_ENGINE_CONFIGURATOR, sslEngineConfigurator);
                </pre><p>
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1172"></a>8.2.&nbsp;Asynchronous connectToServer methods</h2></div></div></div><p>WebSocketContainer.connectToServer(...) methods are by definition blocking - declared exceptions needs to
        be thrown after connection attempt is made and it returns Session instance, which needs to be ready for sending
        messages and invoking other methods, which require already estabilished connection.</p><p>Existing connectToServer methods are fine for lots of uses, but it might cause issue when you are designing
        application with highly responsible user interface. Tyrus introduces asynchronous variants to each connectToServer
        method (prefixed with "async"), which returns Future&lt;Session&gt;. These methods do only simple check for provided
        URL and the rest is executed in separate thread. All exceptions thrown during this phase are reported as cause
        of ExecutionException thrown when calling Future&lt;Session&gt;.get().</p><p>Asynchronous connect methods are declared on Tyrus implementation of WebSocketContainer called ClientManager.</p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientManager client = ClientManager.createClient();
  final Future&lt;Session&gt; future = client.asyncConnectToServer(ClientEndpoint.class, URI.create("..."));
  try {
    future.get();
  } catch (...) {
}</pre><p>ClientManager contains async alternative to each connectToServer method.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1185"></a>8.3.&nbsp;Optimized broadcast</h2></div></div></div><p>One of the typical usecases we've seen so far for WebSocket server-side endpoints is broadcasting messages
        to all connected clients, something like:</p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@OnMessage
public void onMessage(Session session, String message) throws IOException {
  for (Session s : session.getOpenSessions()) {
    s.getBasicRemote().sendText(message);
  }
}</pre><p>Executing this code might cause serious load increase on your application server. Tyrus provides optimized
        broadcast implementation, which takes advantage of the fact, that we are sending exactly same message to all clients,
        so dataframe can be created and serialized only once. Furthermore, Tyrus can iterate over set of opened connections
        faster than Session.getOpenSession().</p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@OnMessage
public void onMessage(Session session, String message) {
  ((TyrusSession) session).broadcast(message);
}</pre><p>Unfortunately, WebSocket API forbids anything else than Session in @OnMessage annotated method parameter,
        so you cannot use TyrusSession there directly and you might need to perform instanceof check.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1198"></a>8.4.&nbsp;Incoming buffer size</h2></div></div></div><p>Sevlet container buffers incoming WebSocket frames and there must be a size limit to precede OutOfMemory
        Exception and potentially DDoS attacks.</p><p>Configuration property is named <code class="code">"org.glassfish.tyrus.servlet.incoming-buffer-size"</code> and you can
        set it in web.xml (this particular snipped sets the buffer size to 17000000 bytes (~16M payload):</p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;

  &lt;context-param&gt;
    &lt;param-name&gt;org.glassfish.tyrus.servlet.incoming-buffer-size&lt;/param-name&gt;
    &lt;param-value&gt;17000000&lt;/param-value&gt;
  &lt;/context-param&gt;
&lt;/web-app&gt;</pre><p>Default value is 4194315, which correspond to 4M plus few bytes to frame headers, so you should be able to
        receive up to 4M long message without the need to care about this property.</p><p>Same issue is present on client side. There you can set this property via ClientManager:</p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientManager client = ClientManager.createClient();
client.getProperties().put("org.glassfish.tyrus.incomingBufferSize", 6000000); // sets the incoming buffer size to 6000000 bytes.
client.connectToServer( ... )</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1216"></a>8.5.&nbsp;Shared client container</h2></div></div></div><p>By default, WebSocket client implementation in Tyrus re-creates client runtime whenever WebSocketContainer#connectToServer
            is invoked. This approach gives us some perks like out-of-the-box isolation and relatively low thread count
            (currently we have 1 selector thread and 2 worker threads). Also it gives you the ability to stop the client
            runtime &#8211; one Session instance is tied to exactly one client runtime, so we can stop it when Session is closed.
            This seems as a good solution for most of WebSocket client use cases &#8211; you usually use java client from
            application which uses it for communicating with server side and you typically don&#8217;t need more than 10 instances
            (my personal estimate is that more than 90% applications won&#8217;t use more than 1 connection). There are several
            reasons for it &#8211; of it is just a client, it needs to preserve server resources &#8211; one WebSocket connection means
            one TCP connection and we don&#8217;t really want clients to consume more than needed. Previous statement may be
            invalidated by WebSocket multiplexing extension, but for now, it is still valid.</p><p>On the other hand, WebSocket client implementations in some other containers took another (also correct)
            approach &#8211; they share client runtime for creating all client connections. That means they might not have this
            strict one session one runtime policy, they cannot really give user way how he to control system resources,
            but surely it has another advantage &#8211; it can handle much more opened connections. Thread pools are share among
            client sessions which may or may not have some unforeseen consequences, but if its implemented correctly, it
            should outperform Tyrus solution mentioned in previous paragraph in some use cases, like the one mentioned
            in <a class="link" href="https://java.net/jira/browse/TYRUS-275" target="_top">TYRUS-275</a> - performance tests. Reporter
            created simple program which used WebSocket API to create clients and connect to remote endpoint and he measured
            how many clients can he create (or in other words: how many parallel client connections can be created; I guess
            that original test case is to measure possible number of concurrent clients on server side, but that does not
            really matter for this post). Tyrus implementation loose compared to some other and it was exactly because it
            did not have shared client runtime capability.</p><p>How can you use this feature?</p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientManager client = ClientManager.createClient();

client.getProperties().put(ClientProperties.SHARED_CONTAINER, true);</pre><p>You might also want to specify container idle timeout:</p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">client.getProperties().put(ClientProperties.SHARED_CONTAINER_IDLE_TIMEOUT, 5);</pre><p>Last but not least, you might want to specify thread pool sizes used by shared container (please use this feature only when you do know what are you doing. Grizzly by default does not limit max number of used threads, so if you do that, please make sure thread pool size fits your purpose):</p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">client.getProperties().put(GrizzlyClientProperties.SELECTOR_THREAD_POOL_CONFIG, ThreadPoolConfig.defaultConfig().setMaxPoolSize(3));
client.getProperties().put(GrizzlyClientProperties.WORKER_THREAD_POOL_CONFIG, ThreadPoolConfig.defaultConfig().setMaxPoolSize(10));</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1238"></a>8.6.&nbsp;WebSocket Extensions</h2></div></div></div><p>Please note that Extensions support is considered to be experimental and any API can be changed anytime. Also,
        you should ask yourself at least twice whether you don't want to achieve your goal by other means - WebSocket
        Extension is very powerful and can easily break your application when not used with care or enough expertise.
        </p><p>WebSocket frame used in ExtendedExtension:</p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class Frame {

    public boolean isFin() { .. }
    public boolean isRsv1() { .. }
    public boolean isRsv2() { .. }
    public boolean isRsv3() { .. }
    public boolean isMask() { .. }
    public byte getOpcode() { .. }
    public long getPayloadLength() { .. }
    public int getMaskingKey() { .. }
    public byte[] getPayloadData() { .. }
    public boolean isControlFrame() { .. }

    public static Builder builder() { .. }
    public static Builder builder(Frame frame) { .. }

    public final static class Builder {

    public Builder() { .. }
    public Builder(Frame frame) { .. }
    public Frame build() { .. }
    public Builder fin(boolean fin) { .. }
    public Builder rsv1(boolean rsv1) { .. }
    public Builder rsv2(boolean rsv2) { .. }
    public Builder rsv3(boolean rsv3) { .. }
    public Builder mask(boolean mask) { .. }
    public Builder opcode(byte opcode) { .. }
    public Builder payloadLength(long payloadLength) { .. }
    public Builder maskingKey(int maskingKey) { .. }
    public Builder payloadData(byte[] payloadData) { .. }
}</pre><p>Frame is immutable, so if you want to create new one, you need to create new builder, modify what you want
        and build it:</p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Frame newFrame = Frame.builder(originalFrame).rsv1(true).build();</pre><p>Note that there is only one convenience method: isControlFrame. Other information about frame type etc needs
            to be evaluated directly from opcode, simply because there might not be enough information to get the correct
            outcome or the information itself would not be very useful. For example: opcode 0&times;00 means continuation frame,
            but you don&#8217;t have any chance to get the information about actual type (text or binary) without intercepting
            data from previous frames. Consider Frame class as raw representation as possible. isControlFrame() can be also
            gathered from opcode, but it is at least always deterministic and it will be used by most of extension
            implementations. It is not usual to modify control frames as it might end with half closed connections or
            unanswered ping messages.</p><p>ExtendedExtension representation needs to be able to handle extension parameter negotiation and actual processing
        of incoming and outgoing frames. It also should be compatible with existing javax.websocket.Extension class, since we
        want to re-use existing registration API and be able to return new extension instance included in response
        from List&lt;Extension&gt; Session.getNegotiatedExtensions() call. Consider following:</p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public interface ExtendedExtension extends Extension {

    Frame processIncoming(ExtensionContext context, Frame frame);
    Frame processOutgoing(ExtensionContext context, Frame frame);

    List onExtensionNegotiation(ExtensionContext context, List requestedParameters);
    void onHandshakeResponse(ExtensionContext context, List responseParameters);

    void destroy(ExtensionContext context);

    interface ExtensionContext {

        Map&lt;String, Object&gt; getProperties();
    }
}</pre><p>ExtendedExtension is capable of processing frames and influence parameter values during the handshake.
            Extension is used on both client and server side and since the negotiation is only place where this fact
            applies, we needed to somehow differentiate these sides. On server side, only onExtensionNegotiation(..)
            method is invoked and on client side onHandshakeResponse(..). Server side method is a must, client side could
            be somehow solved by implementing ClientEndpointConfig.Configurator#afterResponse(..) or calling
            Session.getNegotiatedExtenions(), but it won&#8217;t be as easy to get this information back to extension instance
            and even if it was, it won&#8217;t be very elegant. Also, you might suggest replacing processIncoming and
            processOutgoing methods by just oneprocess(Frame) method. That is also possible, but then you might have to
            assume current direction from frame instance or somehow from ExtensionContext, which is generally not a bad
            idea, but it resulted it slightly less readable code.</p><p>ExtensionContext and related lifecycle method is there because original javax.websocket.Extension is singleton
        and ExtendedExtension must obey this fact. But it does not meet some requirements we stated previously, like per
        connection parameter negotiation and of course processing itself will most likely have some connection state.
        Lifecycle of ExtensionContext is defined as follows: ExtensionContext instance is created right before onExtensionNegotiation
        (server side) or onHandshakeResponse (client side) and destroyed after destroy method invocation. Obviously, processIncoming
        or processOutgoing cannot be called before ExtensionContext is created or after is destroyed. You can think of handshake
        related methods as @OnOpenand destroy as @OnClose.</p><p>For those more familiar with WebSocket protocol: process*(ExtensionContext, Frame) is always invoked with unmasked
        frame, you don&#8217;t need to care about it. On the other side, payload is as it was received from the wire, before any
            validation (UTF-8 check for text messages). This fact is particularly important when you are modifying text
            message content, you need to make sure it is properly encoded in relation to other messages, because encoding/decoding
            process is stateful &#8211; remainder after UTF-8 coding is used as input to coding process for next message. If you
            want just test this feature and save yourself some headaches, don&#8217;t modify text message content or try binary
            messages instead.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1263"></a>8.6.1.&nbsp;ExtendedExtension sample</h3></div></div></div><p>Let&#8217;s say we want to create extension which will encrypt and decrypt first byte of every binary message. Assume we have a key (one byte) and our symmetrical cipher will be XOR. (Just for simplicity (a XOR key XOR key) = a, so encrypt() and decrypt() functions are the same).</p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class CryptoExtension implements ExtendedExtension {

    @Override
    public Frame processIncoming(ExtensionContext context, Frame frame) {
         return lameCrypt(context, frame);
    }

    @Override
    public Frame processOutgoing(ExtensionContext context, Frame frame) {
        return lameCrypt(context, frame);
    }

    private Frame lameCrypt(ExtensionContext context, Frame frame) {
        if(!frame.isControlFrame() &amp;&amp; (frame.getOpcode() == 0x02)) {
            final byte[] payloadData = frame.getPayloadData();
            payloadData[0] ^= (Byte)(context.getProperties().get("key"));

            return Frame.builder(frame).payloadData(payloadData).build();
        } else {
            return frame;
        }
    }

    @Override
    public List onExtensionNegotiation(ExtensionContext context,
                                       List requestedParameters) {
        init(context);
        // no params.
        return null;
    }

    @Override
    public void onHandshakeResponse(ExtensionContext context,
    List responseParameters) {
        init(context);
    }

    private void init(ExtensionContext context) {
        context.getProperties().put("key", (byte)0x55);
    }

    @Override
    public void destroy(ExtensionContext context) {
        context.getProperties().clear();
    }

    @Override
    public String getName() {
        return "lame-crypto-extension";
    }

    @Override
    public List getParameters() {
        // no params.
        return null;
    }
}</pre><p>You can see that ExtendedExtension is slightly more complicated that original Extension so the implementation
            has to be also not as straightforward.. on the other hand, it does something. Sample code above shows possible
            simplification mentioned earlier (one process method will be enough), but please take this as just sample
            implementation. Real world case is usually more complicated.</p><p>Now when we have our CryptoExtension implemented, we want to use it. There is nothing new compared to standard
            WebSocket Java API, feel free to skip this part if you are already familiar with it. Only programmatic version
            will be demonstrated. It is possible to do it for annotated version as well, but it is little bit more complicated
            on the server side and I want to keep the code as compact as possible.</p><p>Client registration</p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ArrayList extensions = new ArrayList();
extensions.add(new CryptoExtension());

final ClientEndpointConfig clientConfiguration =
    ClientEndpointConfig.Builder.create()
    .extensions(extensions).build();

WebSocketContainer client = ContainerProvider.getWebSocketContainer();
final Session session = client.connectToServer(new Endpoint() {
    @Override
    public void onOpen(Session session, EndpointConfig config) {
        // ...
    }
}, clientConfiguration, URI.create(/* ... */));</pre><p>Server registration:</p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class CryptoExtensionApplicationConfig implements ServerApplicationConfig {

    @Override
    public Set getEndpointConfigs(Set&lt;Class&lt;? extends Endpoint&gt;&gt; endpointClasses) {
        Set endpointConfigs = new HashSet();
        endpointConfigs.add(
            ServerEndpointConfig.Builder.create(EchoEndpoint.class, "/echo")
            .extensions(Arrays.asList(new CryptoExtension())).build()
        );
        return endpointConfigs;
    }

    @Override
    public Set&lt;Class&lt;?&gt;&gt; getAnnotatedEndpointClasses(Set&lt;Class&lt;?&gt;&gt; scanned) {
        // all scanned endpoints will be used.
        return scanned;
    }
}

public class EchoEndpoint extends Endpoint {
    @Override
    public void onOpen(Session session, EndpointConfig config) {
        // ...
    }
}</pre><p>CryptoExtensionApplicationConfig will be found by servlets scanning mechanism and automatically used for
                application configuration, no need to add anything (or even have) web.xml.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1284"></a>8.6.2.&nbsp;Per Message Deflate Extension</h3></div></div></div><p>The original goal of whole extension support was to implement Permessage extension as defined in
                draft-ietf-hybi-permessage-compression-15 and we were able to achieve that goal. Well, not completely, current
                implementation ignores parameters. But it seems like it does not matter much, it was tested with Chrome and it
                works fine. Also it passes newest version of Autobahn test suite, which includes tests for this extension.</p><p>see PerMessageDeflateExtension.java (compatible with draft-ietf-hybi-permessage-compression-15, autobahn test suite) and
                XWebKitDeflateExtension.java (compatible with Chrome and Firefox &#8211; same as previous, just different extension name)
                </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1291"></a>8.7.&nbsp;Client reconnect</h2></div></div></div><p>If you need semi-persistent client connection, you can always implement some reconnect logic by yourself,
        but Tyrus Client offers useful feature which should be much easier to use. See short sample code:</p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientManager client = ClientManager.createClient();
ClientManager.ReconnectHandler reconnectHandler = new ClientManager.ReconnectHandler() {

  private int counter = 0;

  @Override
  public boolean onDisconnect(CloseReason closeReason) {
    counter++;
    if (counter &lt;= 3) {
      System.out.println("### Reconnecting... (reconnect count: " + counter + ")");
      return true;
    } else {
      return false;
    }
  }

  @Override
  public boolean onConnectFailure(Exception exception) {
    counter++;
    if (counter &lt;= 3) {
      System.out.println("### Reconnecting... (reconnect count: " + counter + ") " + exception.getMessage());

      // Thread.sleep(...) or something other "sleep-like" expression can be put here - you might want
      // to do it here to avoid potential DDoS when you don't limit number of reconnects.
      return true;
    } else {
      return false;
    }
  }
};

client.getProperties().put(ClientProperties.RECONNECT_HANDLER, reconnectHandler);

client.connectToServer(...)</pre><p>As you can see, ReconnectHandler contains two methods, onDisconnect and onConnectFailure. First will be executed
        whenever @OnClose annotated method (or Endpoint.onClose(..)) is executed on client side - this should happen when
        established connection is lost for any reason. You can find the reason in methods parameter. Other one, called
        onConnectFailure is invoked when client fails to connect to remote endpoint, for example due to temporary network
        issue or current high server load.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1300"></a>8.8.&nbsp;Client behind proxy</h2></div></div></div><p>
            Tyrus client supports traversing proxies, but it is Tyrus specific feature and its configuration is shown
            in the following code sample:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
ClientManager client = ClientManager.createClient();
client.getProperties().put(ClientProperties.PROXY_URI, "http://my.proxy.com:80");
            </pre><p>
            Value is expected to be proxy URI. Protocol part is currently ignored, but must be present.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1308"></a>8.9.&nbsp;JDK 7 client</h2></div></div></div><p>
            As has been said in previous chapters both Tyrus client and server were implemented on top of Grizzly NIO framework.
            This still remains true, but an alternative Tyrus Websocket client implementation based on Java 7 Asynchronous Channel
            API has been available since version 1.6. There are two options how to switch between client implementations.
            If you do not mind using Tyrus specific API, the most straightforward way is to use:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
final ClientManager client = ClientManager.createClient(JdkClientContainer.class.getName());
            </pre><p>
            You just have to make sure that the dependency on JDK client is included in your project:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">
&lt;dependency&gt;
  &lt;groupId&gt;org.glassfish.tyrus&lt;/groupId&gt;
  &lt;artifactId&gt;tyrus-container-jdk-client&lt;/artifactId&gt;
  &lt;version&gt;1.8.1&lt;/version&gt;
&lt;/dependency&gt;
            </pre><p>
            Grizzly client is the default option, so creating a client without any parameters will result in Grizzly client being used.
        </p><p>
            There is also an option how to use JDK client with the standard Websocket API.
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
final WebSocketContainer client = ContainerProvider.getWebSocketContainer();
            </pre><p>
            The code listed above will scan class path for Websocket client implementations. A slight problem with this
            approach is that if there is more than one client on the classpath, the first one discovered will be used.
            Therefore if you intend to use JDK client with the standard API, you have to make sure that there is not
            a Grizzly client on the classpath as it might be used instead.
        </p><p>
            The main reason why JDK client has been implemented is that it does not have any extra dependencies
            except JDK 7 and of course some other Tyrus modules, which makes it considerable more lightweight compared
            to Tyrus Grizzly client, which requires 1.4 MB of dependencies.
        </p><p>
            It is also important to note that the JDK client has been implemented in a way similar to Grizzly client
            shared container option, which means that there is one thread pool shared among all clients.
        </p><p>
            Proxy configuration for JDK client is the same as for Grizzly client shown above.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1330"></a>8.9.1.&nbsp;SSL configuration</h3></div></div></div><p>
                Alike in case of Grizzly client, accessing "wss" URLs will cause Tyrus client to pick up whatever keystore
                and trust store is actually set for the current JVM instance. However, specifying SSL parameters
                to be used with JDK client instance is little different from Grizzly client, because Grizzly client supports
                both
                <a class="link" href="https://grizzly.java.net/docs/2.3/apidocs/org/glassfish/grizzly/ssl/SSLEngineConfigurator.html" target="_top">SSLEngineConfigurator</a>
                end
                <a class="link" href="https://grizzly.java.net/docs/2.3/apidocs/org/glassfish/grizzly/ssl/SSLContextConfigurator.html" target="_top">SSLContextConfigurator</a>
                from Grizzly project and
                <a class="link" href="https://tyrus.java.net/apidocs/1.8.1/org/glassfish/tyrus/client/SslEngineConfigurator.html" target="_top">SslEngineConfigurator</a>
                and
                <a class="link" href="https://tyrus.java.net/apidocs/1.8.1/org/glassfish/tyrus/client/SslContextConfigurator.html" target="_top">SslContextConfigurator</a>
                from Tyrus project, but JDK client supports only the Tyrus version of these classes.
                The following code sample shows an example of some SSL parameters configuration for the JDK client:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
SslContextConfigurator sslContextConfigurator = new SslContextConfigurator();
sslContextConfigurator.setTrustStoreFile("...");
sslContextConfigurator.setTrustStorePassword("...");
sslContextConfigurator.setTrustStoreType("...");
sslContextConfigurator.setKeyStoreFile("...");
sslContextConfigurator.setKeyStorePassword("...");
sslContextConfigurator.setKeyStoreType("...");
SslEngineConfigurator sslEngineConfigurator = new SslEngineConfigurator(sslContextConfigurator, true, false, false);

client.getProperties().put(ClientProperties.SSL_ENGINE_CONFIGURATOR, sslEngineConfigurator);
                </pre><p>
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1350"></a>8.10.&nbsp;JMX Monitoring</h2></div></div></div><p>
            Tyrus allows monitoring and accessing some runtime properties and metrics at the server side using JMX (Java management extension technology).
            The monitoring API has been available since version 1.6 and the following properties are available at runtime
            through MXBeans. Number of open sessions, maximal number of open session since the start of monitoring and
            list of deployed endpoint class names and paths are available for each application. Endpoint class name and path
            the endpoint is registered on, number of open session and maximal number of open sessions are available for each
            endpoint. Apart from that message as well as error statistics are collected both per application and per individual endpoint.
        </p><p>
            The following message statistics are monitored for both sent and received messages:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>messages count</p></li><li class="listitem"><p>messages count per second</p></li><li class="listitem"><p>average message size</p></li><li class="listitem"><p>smallest message size</p></li><li class="listitem"><p>largest message size</p></li></ul></div><p>
            Moreover all of them are collected separately for text, binary and control messages and apart from the statistics being available
            for the three separate categories, total numbers summing up statistics from the three types of messages are also available.
        </p><p>
            As has been already mentioned above, Tyrus also monitors errors on both application and endpoint level.
            An error is identified by the Throwable class name that has been thrown. Statistics are collected about number of times each
            Throwable has been thrown, so a list of errors together with a number of times each error occurred is available on both application and endpoint level.
            The monitored errors correspond to invocation of @OnError method on an annotated endpoint or its equivalent on a programmatic endpoint
            (The invocation of @OnError method is just an analogy and an error will be monitored even if no @OnError method is provided on the endpoint).
            Errors that occur in @OnOpen, @OnClose methods and methods handling incoming messages are monitored. Errors that occurred during handshake
            will not be among the monitored errors.
        </p><p>
            The collected metrics as well as the endpoint properties mentioned above are accessible at runtime through Tyrus MXBeans.
            As has been already mention the information is available on both application and endpoint level with each application
            or endpoint being represented with four MXBeans. One of those MXBeans contains total message statistics for both sent and received
            messages as well as any properties specific for applications or endpoints such as endpoint path in the case of an endpoint.
            The other three MXBeans contain information about sent and received text, binary and control messages.
        </p><p>
            When a user connects to a tyrus application MBean server using an JMX client such as JConsole, they will see
            the following structure:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Application 1 - MXBean containing a list of deployed endpoint class names and paths, number of open sessions,
                        maximal number of open sessions, error and total message statistics for the application.
                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                message statistics - a directory containing message statistics MXBeans
                            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                                        text - MXBean containing text message statistics
                                    </p></li><li class="listitem"><p>
                                        binary - MXBean containing binary message statistics
                                    </p></li><li class="listitem"><p>
                                        control -  MXBean containing control message statistics
                                    </p></li></ul></div></li><li class="listitem"><p>
                                endpoints - a directory containing application endpoint MXBeans
                            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                                        Endpoint 1 - MXBean containing Endpoint 1 class name and path, number of open sessions,
                                        maximal number of open sessions, error and total message statistics for the endpoint.
                                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                                text - MXBean containing text message statistics
                                            </p></li><li class="listitem"><p>
                                                binary - MXBean containing binary message statistics
                                            </p></li><li class="listitem"><p>
                                                control -  MXBean containing control message statistics
                                            </p></li></ul></div></li><li class="listitem"><p>
                                        Endpoint 2
                                    </p></li></ul></div></li></ul></div></li><li class="listitem"><p>
                        Application 2
                    </p></li></ul></div><p>
        </p><p>
            In fact the monitoring structure described above was a little bit simplistic, because there is an additional
            monitoring level available, which causes message metrics being also available per session.
            The monitoring structure is very similar to the one described above, with a small difference that there are
            four MXBeans registered for each session, which contain text, binary, control and total message statistics.
            In order to distinguish the two monitoring levels, they will be referred to as endpoint-level monitoring
            and session-level monitoring.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1424"></a>8.10.1.&nbsp;Configuration</h3></div></div></div><p>
                As has been already mentioned, monitoring is supported only on the server side and is disabled by default.
                The following code sample shows, how endpoint-level monitoring can be enabled on Grizzly server:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
serverProperties.put(ApplicationEventListener.APPLICATION_EVENT_LISTENER, new SessionlessApplicationMonitor());
                </pre><p>
                Similarly endpoint-level monitoring can be enabled on Grizzly server in the following way:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
serverProperties.put(ApplicationEventListener.APPLICATION_EVENT_LISTENER, new SessionAwareApplicationMonitor());
                </pre><p>
                Monitoring can be configured on Glassfish in web.xml and the following code sample shows endpoint-level configuration:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;org.glassfish.tyrus.core.monitoring.ApplicationEventListener&lt;/param-name&gt;
        &lt;param-value&gt;org.glassfish.tyrus.ext.monitoring.jmx.SessionlessApplicationMonitor&lt;/param-value&gt;
    &lt;/context-param&gt;
&lt;/web-app&gt;
                </pre><p>
                Similarly session-level monitoring can be configured on Glassfish in web.xml in the following way:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;org.glassfish.tyrus.core.monitoring.ApplicationEventListener&lt;/param-name&gt;
        &lt;param-value&gt;org.glassfish.tyrus.ext.monitoring.jmx.SessionAwareApplicationMonitor&lt;/param-value&gt;
    &lt;/context-param&gt;
&lt;/web-app&gt;
                </pre><p>
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1441"></a>8.11.&nbsp;Maximal number of open sessions on server-side</h2></div></div></div><p>
            Tyrus offers a few ways to limit the number of open sessions, which can be used to save limited resources
            on a server hosting system. The limits can be configured in several scopes:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">per whole application</li><li class="listitem">per endpoint</li><li class="listitem">per remote address (client IP address)</li></ul></div><p>
            If the number of simultaneously opened sessions exceeds any of these limits, Tyrus will close the session
            with close code 1013 - Try Again Later.
        </p><p>
            Limits mentioned above can be combined together. For example, let's say we have
            an application with two endpoints. Overall limit per application will be 1000 open sessions and the first
            one, non-critical endpoint, will be limited to 75 open sessions at maximum. So we know that the second
            endpoint can handle 925-1000 opened sessions, depends on how many open sessions are connected to
            the first endpoint (0-75).
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1460"></a>8.11.1.&nbsp;Maximal number of open sessions per application</h3></div></div></div><p>
                This configuration property can be used to limit overall number of open sessions per whole application.
                The main purpose of this configurable limit is to restrict how many resources the application can
                consume.
            </p><p>
                The number of open sessions per whole application can be configured by setting property
                <code class="code">org.glassfish.tyrus.maxSessionsPerApp</code>. Property can be used as
                <code class="code">&lt;context-param&gt;</code>
                in
                <code class="code">web.xml</code>
                or as an entry in parameter map in (standalone) Server properties.
            </p><p>
                Note that only positive integer is allowed.
            </p><p>This example will set maximal number of open sessions per whole application to 500:</p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">

&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;org.glassfish.tyrus.maxSessionsPerApp&lt;/param-name&gt;
        &lt;param-value&gt;500&lt;/param-value&gt;
    &lt;/context-param&gt;
&lt;/web-app&gt;

            </pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1482"></a>8.11.2.&nbsp;Maximal number of open sessions per remote address</h3></div></div></div><p>
                The number of open sessions per remote address can be configured by setting property
                <code class="code">org.glassfish.tyrus.maxSessionsPerRemoteAddr</code>. Property can be used as
                <code class="code">&lt;context-param&gt;</code>
                in
                <code class="code">web.xml</code>
                or as an entry in parameter map in (standalone) Server properties.
            </p><p>
                <code class="code">Remote address</code>
                value is obtained from
                <a class="link" href="http://docs.oracle.com/javaee/6/api/javax/servlet/ServletRequest.html#getRemoteAddr()" target="_top">
                    ServletRequest#getRemoteAddr()
                </a>
                or its alternative when using Grizzly server implementation.
                Beware that this method returns always the last node which sending HTTP request, so all clients
                behind one proxy will be treated as clients from single remote address.
            </p><p>
                Note that only positive integer is allowed.
            </p><p>This example will set maximal number of open sessions from unique IP address or last proxy to 5:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">
                
&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;org.glassfish.tyrus.maxSessionsPerRemoteAddr&lt;/param-name&gt;
        &lt;param-value&gt;5&lt;/param-value&gt;
    &lt;/context-param&gt;
&lt;/web-app&gt;

            </pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1510"></a>8.11.3.&nbsp;Maximal number of open sessions per endpoint</h3></div></div></div><p>
                Set maximum number of sessions in annotated endpoint:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.ServerEndpoint;

import org.glassfish.tyrus.core.MaxSessions;

/**
 * Annotated endpoint.
 */
@MaxSessions(100)
@ServerEndpoint(value = "/limited-sessions-endpoint")
public static class LimitedSessionsEndpoint {
    @OnOpen
    public void onOpen(Session s) {
        ...
    }
    ...
}
                </pre><p>
            </p><p>
                Set maximum number of sessions for programmatic endpoint:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
TyrusServerEndpointConfig.Builder.create(LimitedSessionsEndpoint.class,
  "/limited-sessions-endpoint").maxSessions(100).build();
                </pre><p>
            </p><p>
                Note that only positive integer is allowed.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1525"></a>8.12.&nbsp;Client HTTP Authentication</h2></div></div></div><p>
            For server endpoints which is protected by HTTP authentication, Tyrus provides a mechanism to authenticate
            client.
            When client receives HTTP response status code<code class="code">401 - Unauthorized</code>, then Tyrus extracts required
            scheme from
            <code class="code">WWW-Authenticate</code>
            challenge. Then it chooses an
            authenticator from a map of registered authenticators and uses configured<code class="code">credentials</code>.
            If no proper authenticator is found or credentials are missing, then
            <code class="code">AuthenticationException</code>
            is thrown before the handshake can be done.
            There are implementations of the two most used authentication schemes in Tyrus: BASIC and DIGEST, but it is
            also possible to implement your own authenticator and register it with a configuration builder
            <code class="code">org.glassfish.tyrus.client.auth.AuthConfig.Builder</code>
            or even to override default BASIC or DIGEST
            auth implementations.
            If no
            <code class="code">org.glassfish.tyrus.client.auth.AuthConfig</code>
            client property is set, then default
            configuration is used. It is constructed as you can see bellow: BASIC and DIGEST internal implementations
            are
            enabled by default.
        </p><p>
            Please note that Basic Authentication scheme should be used over HTTPS connection only.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1550"></a>8.12.1.&nbsp;Credentials</h3></div></div></div><p>
                Credentials are required for both implemented authentication schemes in Tyrus. You can pass an instance
                into ClientManager as a property:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                    
  client.getProperties().put(ClientProperties.CREDENTIALS, new Credentials("ws_user", "password".getBytes(AuthConfig.CHARACTER_SET));
                    
                </pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1558"></a>8.12.2.&nbsp;Auth Configuration</h3></div></div></div><p>
                <code class="code">org.glassfish.tyrus.client.auth.AuthConfig</code>
                provides a way to configure of HTTP authentication schemes.
                Creating an instance of
                <code class="code">org.glassfish.tyrus.client.auth.AuthConfig</code>
                is optional.
                If you don't specify AuthConfig, then default instance will be created like in following code listing
            </p><p>
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                    
  AuthConfig authConfig = AuthConfig.Builder.create().build();
  ClientManager client = ClientManager.createClient();
  client.getProperties().put(ClientProperties.AUTH_CONFIG, authConfig);
                    
                </pre><p>
            </p><p>
                If authentication is required after an initial upgrade request, Tyrus chooses a proper authentication
                scheme based on a received challenge from server. There are two HTTP authentication scheme implemented
                and registered
                by default.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1576"></a>8.12.3.&nbsp;User defined authenticator</h3></div></div></div><p>
                Tyrus provides an option to implement your own client HTTP authenticator by extending
                <code class="code">org.glassfish.tyrus.client.auth.Authenticator</code>
                and implementing<code class="code">generateAuthorizationHeader</code>.
                Request URI,
                <code class="code">WWW-Authenticate</code>
                response header and provided
                <code class="code">Credentials</code>
                are
                passed as parameters. Method must return response to authentication challenge as it is required by HTTP
                server.
                An instance of the implemented class must be passed to the Tyrus configuration with
                <code class="code">org.glassfish.tyrus.client.auth.AuthConfig.Builder#setAuthScheme(String scheme, Authenticator
                    userDefinedAuthenticator)
                </code>
                and created
                <code class="code">AuthConfig</code>
                instance must be put into client properties.
            </p><p>Authenticator.java</p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                
package org.glassfish.tyrus.client;

import java.net.URI;

/**
 * Http Authentication provider.
 * Class generates authorization token as a input for {@code Authorization} HTTP request header.
 *
 * @author Ondrej Kosatka (ondrej.kosatka at oracle.com)
 */
public abstract class Authenticator {

    /**
     * Generates authorization tokens as a input for {@code Authorization} HTTP request header.
     * @param uri URI is needed for generating authorization tokens for some authentication scheme (DIGEST: {@link DigestAuthenticator})
     * @param wwwAuthenticateHeader a value of header {@code WWW-Authenticate} from HTTP response.
     * @param credentials credentials.
     * @return generated {@link String} value of {@code Authorization}.
     * @throws AuthenticationException if is not possible to create auth token.
     */
    public abstract String generateAuthorizationHeader(final URI uri, final String wwwAuthenticateHeader, final Credentials credentials) throws AuthenticationException;

}
                
            </pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1603"></a>8.12.4.&nbsp;Examples</h3></div></div></div><p>
                The simplest way to setup Tyrus authentication is by adding client property
                <code class="code">ClientProperties.CREDENTIALS</code>
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                    
  client.getProperties().put(ClientProperties.CREDENTIALS, new Credentials("ws_user", "password");
                    
                </pre><p>
            </p><p>
                How to configure Tyrus with suppressing Basic authentication, even if server side challenges Basic
                authentication scheme.
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                    
  AuthConfig authConfig = AuthConfig.Builder.create().
                               disableBasicAuth().
                               build();
  Credentials credentials = new Credentials("ws_user", "password");
  client.getProperties().put(ClientProperties.AUTH_CONFIG, authConfig);
  client.getProperties().put(ClientProperties.CREDENTIALS, credentials);
                    
                </pre><p>
            </p><p>
                How to configure Tyrus using user defined DIGEST authentication and Tyrus Basic authentication. User
                defined
                authentication provider
                <code class="code">MyOwnDigestAuthenticator</code>
                must extend<code class="code">org.glassfish.tyrus.client.auth.Authenticator</code>.
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                    
  AuthConfig authConfig = AuthConfig.Builder.create().
                               putAuthProvider("Digest", new MyOwnDigestAuthenticator()).
                               build();
  Credentials credentials = new Credentials("ws_user", "password");
  client.getProperties().put(ClientProperties.AUTH_CONFIG, authConfig);
  client.getProperties().put(ClientProperties.CREDENTIALS, credentials);
                
                </pre><p>
            </p><p>
                How to configure Tyrus using user defined NTLM authentication and suppress Tyrus Basic authentication,
                even if server side challenges Basic authentication scheme.. User defined
                authentication provider
                <code class="code">MyOwnNTLMAuthenticator</code>
                must extend<code class="code">org.glassfish.tyrus.client.auth.Authenticator</code>.
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                    
  AuthConfig authConfig = AuthConfig.Builder.create().
                               disableBasicAuth().
                               putAuthProvider("NTLM", new MyOwnNTLMAuthenticator()).
                               build();
  Credentials credentials = new Credentials("ws_user", "password");
  client.getProperties().put(ClientProperties.AUTH_CONFIG, authConfig);
  client.getProperties().put(ClientProperties.CREDENTIALS, credentials);
                
                </pre><p>
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1641"></a>8.13.&nbsp;Client HTTP Redirect</h2></div></div></div><p>
            Another Tyrus feature is HTTP redirect. If client&nbsp;received 3xx HTTP Redirect response code during a
            handshake and HTTP Redirect is allowed (by <code class="code">ClientProperty.REDIRECT_ENABLED</code>
            property) then client engine  transparently follows the URI contained in received HTTP response header
            <code class="code">Location</code> and sends upgrade request to the new URI. Redirects can be chained up to limit set in
            <code class="code">ClientProperty.REDIRECT_THRESHOLD</code>, whilst default value is 5.
            If HTTP redirect failed by any reason, <code class="code">RedirectException</code> is thrown.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1658"></a>8.13.1.&nbsp;Supported HTTP response codes</h3></div></div></div><p>
                List of 3xx HTTP response codes which can be automatically redirect
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>300 - Multiple Choices</p></li><li class="listitem"><p>301 - Moved permanently</p></li><li class="listitem"><p>302 - Found</p></li><li class="listitem"><p>303 - See Other (since HTTP/1.1)</p></li><li class="listitem"><p>307 - Temporary Redirect (since HTTP/1.1)</p></li><li class="listitem"><p>308 - Permanent Redirect (Experimental RFC; RFC 7238)</p></li></ul></div><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1683"></a>8.13.2.&nbsp;Configuration</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1686"></a>8.13.2.1.&nbsp;Enabling</h4></div></div></div><p>
                    For enabling HTTP Redirect feature, <code class="code">ClientProperty.REDIRECT_ENABLED</code> must be explicitly set to
                    <code class="code">true</code> (default value is<code class="code">false</code>), otherwise <code class="code">RedirectException</code>
                    will be thrown, when any of supported HTTP Redirect response codes (see above).
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">
                    client.getProperties().put(ClientProperties.REDIRECT_ENABLED, true);
                </pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1705"></a>8.13.2.2.&nbsp;Threshold</h4></div></div></div><p>
                    <code class="code">ClientProperty.REDIRECT_THRESHOLD</code> is property which can be used to limit maximal
                    number of chained redirect. Positive integer is expected and default value is 5.
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">
                    client.getProperties().put(ClientProperties.REDIRECT_THRESHOLD, 3);
                </pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1715"></a>8.13.3.&nbsp;Exception handling</h3></div></div></div><p>
                <code class="code">RedirectException</code>
                is set as a cause of DeploymentException when any of the supported Redirection HTTP response
                status codes (see above) was received and WebSocketContainer.connectToServer(...) fails
                because of any of the following reasons:
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="code">ClientProperties.REDIRECT_ENABLED</code> property is not set to true.
                        </p></li><li class="listitem"><p>
                            Value of <code class="code">ClientProperties.REDIRECT_THRESHOLD</code> is not assignable to Integer.
                        </p></li><li class="listitem"><p>
                            Number of chained redirection exceeds a value of <code class="code">ClientProperties.REDIRECT_THRESHOLD</code>
                            (default value is 5).
                        </p></li><li class="listitem"><p>Infinite redirection loop is detected.</p></li><li class="listitem"><p>
                            <code class="code">Location</code> response header is missing, is empty or does not contain a valid URI.
                        </p></li></ul></div><p>
            </p></div></div></div><link href="http://tyrus.java.net/sh/shCore.css" rel="stylesheet" type="text/css"><link href="http://tyrus.java.net/sh/shThemeDefault.css" rel="stylesheet" type="text/css"><script src="http://tyrus.java.net/sh/shCore.js" type="text/javascript"></script><script src="http://tyrus.java.net/sh/shAutoloader.js" type="text/javascript"></script><script type="text/javascript">
            function path() {
              var args = arguments,
                  result = []
                  ;

              for(var i = 0; i < args.length; i++)
                  result.push(args[i].replace('@', 'http://tyrus.java.net/sh/'));

              return result
            };

            SyntaxHighlighter.autoloader.apply(null, path(
              'applescript            @shBrushAppleScript.js',
              'actionscript3 as3      @shBrushAS3.js',
              'bash shell             @shBrushBash.js',
              'coldfusion cf          @shBrushColdFusion.js',
              'cpp c                  @shBrushCpp.js',
              'c# c-sharp csharp      @shBrushCSharp.js',
              'css                    @shBrushCss.js',
              'delphi pascal          @shBrushDelphi.js',
              'diff patch pas         @shBrushDiff.js',
              'erl erlang             @shBrushErlang.js',
              'groovy                 @shBrushGroovy.js',
              'java                   @shBrushJava.js',
              'jfx javafx             @shBrushJavaFX.js',
              'js jscript javascript  @shBrushJScript.js',
              'perl pl                @shBrushPerl.js',
              'php                    @shBrushPhp.js',
              'text plain             @shBrushPlain.js',
              'py python              @shBrushPython.js',
              'ruby rails ror rb      @shBrushRuby.js',
              'sass scss              @shBrushSass.js',
              'scala                  @shBrushScala.js',
              'sql                    @shBrushSql.js',
              'vb vbnet               @shBrushVb.js',
              'xml xhtml xslt html    @shBrushXml.js'
            ));

            SyntaxHighlighter.all();
        </script><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-41373632-1', 'java.net');
              ga('send', 'pageview');
        </script><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="injection.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;</td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;7.&nbsp;Injection Support&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;</td></tr></table></div></div></body></html>